#define pARMVM mmu->armvm
#define pARMVM_CORE pARMVM->core

#include "armvm_mmu.h"

/* **** */

#include "armvm_coprocessor_cp15.h"
#include "armvm_coprocessor.h"
#include "armvm_core.h"
#include "armvm.h"

/* **** */

#include "libbse/include/action.h"
#include "libbse/include/bitops.h"
#include "libbse/include/err_test.h"
#include "libbse/include/log.h"

/* **** */

#include <assert.h>
#include <stdint.h>

/* **** */

#undef DEBUG
#define DEBUG(_x) _x

#ifndef DEBUG
	#define DEBUG(...)
#endif

/* **** */

static uint32_t _mmu_cp15__0_2_0_0__ttbr(armvm_mmu_ref mmu, uint32_t *const write, const unsigned r)
{
	const uint32_t mask = mlBF(31, 14 - TTBCR_N) | mlBF(4, 3) | _BV(2) | _BV(1) | _BV(0);

	uint32_t* p2ttbr = armvm_coprocessor_cp15r_rmw(mmu->cp, rSPR32(IR));

	const uint32_t data = write ? *write : *p2ttbr;

	if(write) {
		LOG_START("Translation Table Base %01u\n\t", r);
		_LOG_("mmu->ttbr[0]: 0x%08x", mlBFTST(data, 31, 14 - TTBCR_N));
		_LOG_(" SBZ: 0x%03x", mlBFEXT(data, 13, 5));
		_LOG_(" RGN: %01u", mlBFEXT(data, 4, 3));
		_LOG_(" IMP: %01u", BEXT(data, 2));
		_LOG_(" %c", BEXT(data, 1) ? 'S' : 's');
		LOG_END(" %c", BEXT(data, 0) ? 'C' : 'c');

		*p2ttbr = data & mask;
	} else {
		DEBUG(LOG("READ -- Translation Table Base %01u", r));
	}

	return(data);
}

static uint32_t _mmu_cp15__0_2_0_0_ttbr0(void *const param, uint32_t *const write)
{ return(_mmu_cp15__0_2_0_0__ttbr(param, write, 0)); }

static uint32_t _mmu_cp15__0_2_0_1_ttbr1(void *const param, uint32_t *const write)
{ return(_mmu_cp15__0_2_0_0__ttbr(param, write, 0)); }

static uint32_t _mmu_cp15__0_2_0_2_ttbcr(void *const param, uint32_t *const write)
{
	armvm_mmu_ref mmu = param;

	const uint32_t ttbcr = armvm_coprocessor_cp15r(mmu->cp, rSPR32(IR), write);

	if(write) {
		assert(0 == mlBFEXT(rSPR32(IR), 31, 3));

		LOG("n: %u", mlBFEXT(ttbcr, 2, 0));
	}

	return(ttbcr);
}

static
int armvm_mmu_cp15_action_init(int err, void *const param, action_ref)
{
	ACTION_LOG(init);
	ERR_NULL(param);

	armvm_mmu_ref mmu = param;

	/* **** */

	armvm_coprocessor_register_callback(mmu->cp, cp15(0, 2, 0, 0), _mmu_cp15__0_2_0_0_ttbr0, mmu);
	armvm_coprocessor_register_callback(mmu->cp, cp15(0, 2, 0, 1), _mmu_cp15__0_2_0_1_ttbr1, mmu);
	armvm_coprocessor_register_callback(mmu->cp, cp15(0, 2, 0, 2), _mmu_cp15__0_2_0_2_ttbcr, mmu);

	/* **** */

	return(err);
}

action_list_t armvm_mmu_cp15_action_list = {
	.list = {
		[_ACTION_INIT] = {{ armvm_mmu_cp15_action_init }, { 0 }, 0 }
	}
};
